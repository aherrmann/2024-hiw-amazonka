self: super:

let

  compilerName = import ../compiler.nix;
  hackage-index = import ../hackage-index.nix;

  inherit
    (self.haskell.lib.compose)
    addBuildDepends
    appendPatch
    appendPatches
    disableCabalFlag
    doHaddock
    doJailbreak
    dontCheck
    overrideCabal
    packageSourceOverrides;

  dontUpdateCabalFile = overrideCabal (drv: {
    editedCabalFile = null;
    revision = null;
  });

  ### Choosing a Hackage Version ###
  #
  # Add a `package-name = "A.B.X.Y";` line in this record to select a Hackage
  # version of the package to depend on. Please try to keep the list sorted.
  overlay-packageSourceOverrides = packageSourceOverrides {
    bifunctors = "5.6.2";
    doctest = "0.22.2";
    hspec = "2.11.7";
    hspec-core = "2.11.7";
    hspec-discover = "2.11.7";
    hspec-expectations = "0.8.4";
    primitive = "0.9.0.0";
    semigroupoids = "6.0.0.1";
    th-abstraction = "0.6.0.0";
    uuid-types = "1.0.5.1";
    tagged = "0.8.8";
  };

  # IMPORTANT
  #
  # If you add a new override to this section, leave a detailed reason why we need this override.
  # This is important because when we later upgrade nixpkgs, we need to know if we still need that specific version, or can ugprade.
  haskell-overlay = self: super: hself: hsuper:
    with super.haskell.lib;
    rec {
      # normal callHackage keeps the deriver ; we donâ€™t want that
      callHackage = name: version: args:
        let
          src = hself.hackage2nix name version;
        in
        overrideCabal
          (orig: {
            passthru =
              orig.passthru
                or { }
              // {
                # When using callCabal2nix or callHackage, it is often useful
                # to debug a failure by inspecting the Nix expression
                # generated by cabal2nix. This can be accessed via this
                # cabal2nixDeriver field.
                cabal2nixDeriver = src;
              };
          })
          (hself.callPackage src args);

      system-cxx-std-lib = null;
      async = doJailbreak hsuper.async;
      bifunctors = doJailbreak hsuper.bifunctors;
      hspec-core = dontCheck hsuper.hspec-core;
      hspec-discover = dontCheck hsuper.hspec-discover;
      hspec = dontCheck hsuper.hspec;
      indexed-traversable = doJailbreak hsuper.indexed-traversable;
      integer-conversion = doJailbreak hsuper.integer-conversion;
      network-uri = doJailbreak hsuper.network-uri;
      primitive = dontCheck hsuper.primitive;
      quickcheck-instances = doJailbreak hsuper.quickcheck-instances;
      scientific = doJailbreak hsuper.scientific;
      splitmix = doJailbreak hsuper.splitmix;
      unliftio-core = doJailbreak hsuper.unliftio-core;
      unordered-containers = doJailbreak hsuper.unordered-containers;
    }
    // (
      let
        src = self.fetchFromGitHub {
          owner = "haskell";
          repo = "aeson";
          # v2.2.1.0
          rev = "23df6ccdbd0fd2596d0ba91654c3e3a0bade092b";
          hash = "sha256-Wv0XODMZ9R68+PkTxyhC/+kiNWmpedXGpRKi4ge8CxM=";
        };
        overrideAeson = name: (hself.callCabal2nixWithOptions name
          src (
            if name == "aeson"
            then ""
            else "--subpath ${name}"
          ) {});
      in {
        aeson = doJailbreak (overrideAeson "aeson");
        text-iso8601 = overrideAeson "text-iso8601";
      }
    );

in

{
  haskell = super.haskell // {
    packages = super.haskell.packages // {
      "${compilerName}" =
        let
          oldCompiler = super.haskell.packages.${compilerName};
          oldCompilerWithUpdatedHackage = oldCompiler.override { all-cabal-hashes = super.fetchurl hackage-index; };
        in
        oldCompilerWithUpdatedHackage.override (prev: {
          overrides =
            self.lib.fold
              self.lib.composeExtensions
              (prev.overrides or (_: _: { }))
              [ overlay-packageSourceOverrides (haskell-overlay self super) ];
        });
    };
  };
}
