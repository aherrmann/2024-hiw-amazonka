self: super:

let

  compilerName = import ../compiler.nix;
  hackage-index = import ../hackage-index.nix;

  inherit
    (self.haskell.lib.compose)
    addBuildDepends
    appendPatch
    appendPatches
    disableCabalFlag
    doHaddock
    doJailbreak
    dontCheck
    overrideCabal
    packageSourceOverrides;

  dontUpdateCabalFile = overrideCabal (drv: {
    editedCabalFile = null;
    revision = null;
  });

  ### Choosing a Hackage Version ###
  #
  # Add a `package-name = "A.B.X.Y";` line in this record to select a Hackage
  # version of the package to depend on. Please try to keep the list sorted.
  overlay-packageSourceOverrides = packageSourceOverrides {
    bifunctors = "5.6.2";
    doctest = "0.22.2";
    hedgehog = "1.4";
    hspec = "2.11.7";
    hspec-core = "2.11.7";
    hspec-discover = "2.11.7";
    hspec-expectations = "0.8.4";
    http-conduit = "2.3.8.3";
    primitive = "0.9.0.0";
    semigroupoids = "6.0.0.1";
    tasty-hedgehog = "1.4.0.2";
    th-abstraction = "0.6.0.0";
    uuid-types = "1.0.5.1";
    tagged = "0.8.8";
  };

  # IMPORTANT
  #
  # If you add a new override to this section, leave a detailed reason why we need this override.
  # This is important because when we later upgrade nixpkgs, we need to know if we still need that specific version, or can ugprade.
  haskell-overlay = self: super: hself: hsuper:
    with super.haskell.lib;
    rec {
      # normal callHackage keeps the deriver ; we donâ€™t want that
      callHackage = name: version: args:
        let
          src = hself.hackage2nix name version;
        in
        overrideCabal
          (orig: {
            passthru =
              orig.passthru
                or { }
              // {
                # When using callCabal2nix or callHackage, it is often useful
                # to debug a failure by inspecting the Nix expression
                # generated by cabal2nix. This can be accessed via this
                # cabal2nixDeriver field.
                cabal2nixDeriver = src;
              };
          })
          (hself.callPackage src args);

      system-cxx-std-lib = null;
      async = doJailbreak hsuper.async;
      attoparsec = doJailbreak hsuper.attoparsec;
      bifunctors = doJailbreak hsuper.bifunctors;
      bitvec = doJailbreak hsuper.bitvec;
      concurrent-output = doJailbreak hsuper.concurrent-output;
      foldl = doJailbreak hsuper.foldl;
      free = doJailbreak hsuper.free;
      hourglass = dontCheck hsuper.hourglass;
      hspec-core = dontCheck hsuper.hspec-core;
      hspec-discover = dontCheck hsuper.hspec-discover;
      hspec = dontCheck hsuper.hspec;
      http-client = doJailbreak hsuper.http-client;
      indexed-traversable = doJailbreak hsuper.indexed-traversable;
      integer-conversion = doJailbreak hsuper.integer-conversion;
      lifted-async = doJailbreak hsuper.lifted-async;
      lifted-base =
        appendPatch
          (self.fetchpatch {
            url = "https://github.com/basvandijk/lifted-base/pull/35.patch";
            hash = "sha256-b29AVDiEMcShceRJyKEauK/411UkOh3ME9AnKEYvcEs=";
          })
          hsuper.lifted-base;
      network-uri = doJailbreak hsuper.network-uri;
      primitive = dontCheck hsuper.primitive;
      primitive-addr = doJailbreak hsuper.primitive-addr;
      quickcheck-classes = doJailbreak hsuper.quickcheck-classes;
      quickcheck-instances = doJailbreak hsuper.quickcheck-instances;
      safe-exceptions = doJailbreak hsuper.safe-exceptions;
      scientific = doJailbreak hsuper.scientific;
      splitmix = doJailbreak hsuper.splitmix;
      streaming-commons = doJailbreak hsuper.streaming-commons;
      type-equality = doJailbreak hsuper.type-equality;
      unliftio-core = doJailbreak hsuper.unliftio-core;
      unordered-containers = doJailbreak hsuper.unordered-containers;
      vector-algorithms = doJailbreak hsuper.vector-algorithms;
      wl-pprint-annotated = doJailbreak hsuper.wl-pprint-annotated;
    }
    // (
      let
        src = self.fetchFromGitHub {
          owner = "haskell";
          repo = "aeson";
          # v2.2.1.0
          rev = "23df6ccdbd0fd2596d0ba91654c3e3a0bade092b";
          hash = "sha256-Wv0XODMZ9R68+PkTxyhC/+kiNWmpedXGpRKi4ge8CxM=";
        };
        overrideAeson = name: (hself.callCabal2nixWithOptions name
          src
          (
            if name == "aeson"
            then ""
            else "--subpath ${name}"
          )
          { });
      in
      {
        aeson = doJailbreak (overrideAeson "aeson");
        attoparsec-aeson = doJailbreak (dontUpdateCabalFile (overrideAeson "attoparsec-aeson"));
        text-iso8601 = overrideAeson "text-iso8601";
      }
    );

in

{
  haskell = super.haskell // {
    packages = super.haskell.packages // {
      "${compilerName}" =
        let
          oldCompiler = super.haskell.packages.${compilerName};
          oldCompilerWithUpdatedHackage = oldCompiler.override { all-cabal-hashes = super.fetchurl hackage-index; };
        in
        oldCompilerWithUpdatedHackage.override (prev: {
          overrides =
            self.lib.fold
              self.lib.composeExtensions
              (prev.overrides or (_: _: { }))
              [ overlay-packageSourceOverrides (haskell-overlay self super) ];
        });
    };
  };
}
